// Автор:Высоцкая И.Д.
#include <iostream>
#include "Binary_tree.h"

using namespace std; // используем пространство имен std для того, чтобы не писать перед функциями cin, cout "std"

int main()
{
    test();
    system("cls"); // очистка консоли
    Tree_Node<int>* root = new Tree_Node<int>(8); // выделяем память под корень дерева
    vector<int> arr; // массив для записи
    AddNode(4, root); // добавляем узел дерева
    AddNode(6, root); // добавляем узел дерева
    AddNode(7, root->right); // добавляем узел дерева
    AddNode(10, root->right); // добавляем узел дерева
    /*     8
    *    /    \
    *   4      6
    *         /   \
    *        7    10
    * Дерево плотное, строгое, неполное, незаконченное
    * Плотное дерево - дерево, на каждом уровне которого весь или почти весь набор узлов.
    * Вырожденное дерево - дерево на каждом уровне которого у каждого узла есть только один потомок.
    * Строгое дерево - дерево у которого каждый узел имеет 0, либо 2 потомка.
    * Законченное дерево - дерево, на каждом уровне 0..N-1 полный набор узлов и все листья уровня N находятся слева.
    * Совершенное(полное) дерево - дерево у которого на каждом уровне полный набор узлов.
    */
    NLR(root, arr); // обход NLR
    cout << "\n";
    for (size_t i = 0; i < arr.size(); i++)
    {
        cout << arr[i] << " "; // вывод массива на экран
    }
    Del_Tree(root); // удаление дерева
}